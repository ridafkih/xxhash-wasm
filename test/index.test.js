import test from "jest-t-assert";
import xxhash from "../src";

// The test cases were taken from tests of other implementation and the
// resulting hashes have been generated by running another implementation.
// All cases used the seed 0.
const testCases = [
  { input: "", h32: "02cc5d05", h64: "ef46db3751d8e999" },
  { input: "a", h32: "550d7456", h64: "d24ec4f1a98c6e5b" },
  { input: "as", h32: "9d5a0464", h64: "1c330fb2d66be179" },
  { input: "asd", h32: "3d83552b", h64: "631c37ce72a97393" },
  { input: "asdf", h32: "5e702c32", h64: "415872f599cea71e" },
  { input: "abc", h32: "32d153ff", h64: "44bc2cf5ad770999" },
  { input: "abcd", h32: "a3643705", h64: "de0327b0d25d92cc" },
  { input: "0.7278296545100061", h32: "432c173f", h64: "596877150e8ee48c" },
  {
    input: "Call me Ishmael. Some years ago--never mind how long precisely-",
    h32: "6f320359",
    h64: "02a2e85470d6fd96",
  },
  {
    input:
      "The quick brown fox jumps over the lazy dog http://i.imgur.com/VHQXScB.gif",
    h32: "5ce7b616",
    h64: "93267f9820452ead",
  },
  { input: "heiå", h32: "db5abccc", h64: "b9d3d990d2001a1a" },
  { input: "κόσμε", h32: "d855f606", h64: "a0488960c70d8772" },
];

for (const testCase of testCases) {
  test(`h32 of ${testCase.input}`, (t) => {
    const hasher = xxhash();
    const h32 = hasher.h32(testCase.input).toString(16).padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`h32ToString of ${testCase.input}`, (t) => {
    const hasher = xxhash();
    const h32 = hasher.h32ToString(testCase.input);
    t.is(h32, testCase.h32);
  });

  test(`h32Raw of ${testCase.input}`, (t) => {
    const encoder = new TextEncoder();
    const hasher = xxhash();
    const h32 = hasher
      .h32Raw(encoder.encode(testCase.input))
      .toString(16)
      .padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`streamed h32 of ${testCase.input}`, (t) => {
    const hasher = xxhash();
    const h32 = hasher
      .create32()
      .update(testCase.input)
      .digest()
      .toString(16)
      .padStart(8, "0");
    t.is(h32, testCase.h32);
  });

  test(`h64 of ${testCase.input}`, (t) => {
    const hasher = xxhash();
    const h64 = hasher.h64(testCase.input);
    t.is(h64, BigInt(`0x${testCase.h64}`));
  });

  test(`h64ToString of ${testCase.input}`, (t) => {
    const hasher = xxhash();
    const h64 = hasher.h64ToString(testCase.input);
    t.is(h64, testCase.h64);
  });

  test(`h64Raw of ${testCase.input}`, (t) => {
    const encoder = new TextEncoder();
    const hasher = xxhash();
    const h64 = hasher.h64Raw(encoder.encode(testCase.input));
    t.is(h64, BigInt(`0x${testCase.h64}`));
  });

  test(`streamed h64 of ${testCase.input}`, (t) => {
    const hasher = xxhash();
    const h64 = hasher
      .create64()
      .update(testCase.input)
      .digest()
      .toString(16)
      .padStart(16, "0");
    t.is(h64, testCase.h64);
  });
}

test("h32 with different seeds produces different hashes", (t) => {
  const hasher = xxhash();
  const input = "different seeds";
  const h320 = hasher.h32(input, 0);
  const h32abcd = hasher.h32(input, 0xabcd);
  t.not(h320, h32abcd);
});

test("h64 with different seeds produces different hashes", (t) => {
  const hasher = xxhash();
  const input = "different seeds";
  const h640 = hasher.h64(input, 0n);
  const h64lowAbcd = hasher.h64(input, BigInt(0xabcd));
  const h64highAbcd = hasher.h64(input, BigInt(0xabcd) << (32n + BigInt(0)));
  t.not(h640, h64lowAbcd);
  t.not(h640, h64highAbcd);
  t.not(h64lowAbcd, h64highAbcd);
});

test("a string greater than the initial memory size works", (t) => {
  const hasher = xxhash();
  const bytesPerPage = 64 * 1024;
  const input = "z".repeat(bytesPerPage + 1);
  const h32 = hasher.h32ToString(input, 0);
  const h64 = hasher.h64ToString(input, 0n);
  t.is(h32, "7871ee9b");
  t.is(h64, "68278ba56dc14510");
});

test("streamed h32 with multiple inputs produces same hash", (t) => {
  const hasher = xxhash();
  const { update, digest } = hasher.create32(0);
  update("hello");
  update("world");
  t.is(digest(), hasher.h32("helloworld"));
});

test("streamed h64 with multiple inputs produces same hash", (t) => {
  const hasher = xxhash();
  const { update, digest } = hasher.create64(0n);
  update("hello");
  update("world");
  t.is(digest(), hasher.h64("helloworld"));
});

test("streamed h32 with buffer input produces same hash", (t) => {
  const input = Buffer.from("helloworld");
  const hasher = xxhash();
  t.is(hasher.create32(0).update(input).digest(), hasher.h32Raw(input));
});

test("streamed h64 with buffer input produces same hash", (t) => {
  const input = Buffer.from("helloworld");
  const hasher = xxhash();
  t.is(hasher.create64(0n).update(input).digest(), hasher.h64Raw(input));
});
